use crate::from_bytes::FromBytes;
use crate::Result;

pub trait SolidityResult<'a> {
    fn get_param<F: FromBytes<'a, F>>(&self, index: usize) -> Result<F>;
}

impl<'a> SolidityResult<'a> for &'a [u8] {
    fn get_param<F: FromBytes<'a, F>>(&self, index: usize) -> Result<F> {
        F::from_bytes(&self, index)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::{i256, u256};

    #[test]
    #[rustfmt::skip]
    fn decode_numbers() -> anyhow::Result<()> {
        let bytes   = hex::decode("\
00000000000000000000000000000000000000000000000000000000000000ff\
00000000000000000000000000000000000000000000000000000000000000ff\
000000000000000000000000000000000000000000000000000000000000ffff\
000000000000000000000000000000000000000000000000000000000000ffff\
00000000000000000000000000000000000000000000000000000000ffffffff\
00000000000000000000000000000000000000000000000000000000ffffffff\
000000000000000000000000000000000000000000000000ffffffffffffffff\
000000000000000000000000000000000000000000000000ffffffffffffffff\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
").unwrap();

        assert_eq!((&*bytes).get_param::<i8>(0)?,   0xffu8                                 as i8);
        assert_eq!((&*bytes).get_param::<u8>(1)?,   0xffu8);
        assert_eq!((&*bytes).get_param::<i16>(2)?,  0xffffu16                              as i16);
        assert_eq!((&*bytes).get_param::<u16>(3)?,  0xffffu16);
        assert_eq!((&*bytes).get_param::<i32>(4)?,  0xffffffffu32                          as i32);
        assert_eq!((&*bytes).get_param::<u32>(5)?,  0xffffffffu32);
        assert_eq!((&*bytes).get_param::<i64>(6)?,  0xffffffffffffffffu64                  as i64);
        assert_eq!((&*bytes).get_param::<u64>(7)?,  0xffffffffffffffffu64);
        assert_eq!((&*bytes).get_param::<i128>(8)?, 0xffffffffffffffffffffffffffffffffu128 as i128);
        assert_eq!((&*bytes).get_param::<u128>(9)?, 0xffffffffffffffffffffffffffffffffu128);
        
        Ok(())
    }

    #[test]
    #[rustfmt::skip]
    fn decode_numbers_array() -> anyhow::Result<()> {
        let bytes   = hex::decode("\
0000000000000000000000000000000000000000000000000000000000000180\
00000000000000000000000000000000000000000000000000000000000001e0\
0000000000000000000000000000000000000000000000000000000000000240\
00000000000000000000000000000000000000000000000000000000000002a0\
0000000000000000000000000000000000000000000000000000000000000300\
0000000000000000000000000000000000000000000000000000000000000360\
00000000000000000000000000000000000000000000000000000000000003c0\
0000000000000000000000000000000000000000000000000000000000000420\
0000000000000000000000000000000000000000000000000000000000000480\
00000000000000000000000000000000000000000000000000000000000004e0\
0000000000000000000000000000000000000000000000000000000000000540\
00000000000000000000000000000000000000000000000000000000000005a0\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000000000000000000000000000000000ff\
00000000000000000000000000000000000000000000000000000000000000ff\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000000000000000000000000000000000ff\
00000000000000000000000000000000000000000000000000000000000000ff\
0000000000000000000000000000000000000000000000000000000000000002\
000000000000000000000000000000000000000000000000000000000000ffff\
000000000000000000000000000000000000000000000000000000000000ffff\
0000000000000000000000000000000000000000000000000000000000000002\
000000000000000000000000000000000000000000000000000000000000ffff\
000000000000000000000000000000000000000000000000000000000000ffff\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000000000000000000000000000ffffffff\
00000000000000000000000000000000000000000000000000000000ffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000000000000000000000000000ffffffff\
00000000000000000000000000000000000000000000000000000000ffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
000000000000000000000000000000000000000000000000ffffffffffffffff\
000000000000000000000000000000000000000000000000ffffffffffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
000000000000000000000000000000000000000000000000ffffffffffffffff\
000000000000000000000000000000000000000000000000ffffffffffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
00000000000000000000000000000000ffffffffffffffffffffffffffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
0000000000000000000000000000000000000000000000000000000000000002\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
").unwrap();

        assert_eq!((&*bytes).get_param::<Vec<i8>>(0)?,   &[0xffu8                                  as i8;   2]);
        // Vec<u8> is unsupported because it fits solidity type `Bytes` better.
        // assert_eq!((&*bytes).get_param::<Vec<u8>>(1)?,   &[0xffu8;                                 2]);
        assert_eq!((&*bytes).get_param::<Vec<i16>>(2)?,  &[0xffffu16                               as i16;  2]);
        assert_eq!((&*bytes).get_param::<Vec<u16>>(3)?,  &[0xffffu16;                              2]);
        assert_eq!((&*bytes).get_param::<Vec<i32>>(4)?,  &[0xffffffffu32                           as i32;  2]);
        assert_eq!((&*bytes).get_param::<Vec<u32>>(5)?,  &[0xffffffffu32;                          2]);
        assert_eq!((&*bytes).get_param::<Vec<i64>>(6)?,  &[0xffffffffffffffffu64                   as i64;  2]);
        assert_eq!((&*bytes).get_param::<Vec<u64>>(7)?,  &[0xffffffffffffffffu64;                  2]);
        assert_eq!((&*bytes).get_param::<Vec<i128>>(8)?, &[0xffffffffffffffffffffffffffffffffu128  as i128; 2]);
        assert_eq!((&*bytes).get_param::<Vec<u128>>(9)?, &[0xffffffffffffffffffffffffffffffffu128; 2]);
        assert_eq!((&*bytes).get_param::<Vec<i256>>(10)?, &[i256([0xffu8; 32]); 2]);
        assert_eq!((&*bytes).get_param::<Vec<u256>>(11)?, &[u256([0xffu8; 32]); 2]);
        
        Ok(())
    }

    #[test]
    #[rustfmt::skip]
    fn decode_string() -> anyhow::Result<()> {
        let bytes   = hex::decode("\
0000000000000000000000000000000000000000000000000000000000000040\
0000000000000000000000000000000000000000000000000000000000000080\
000000000000000000000000000000000000000000000000000000000000000d\
72616e646f6d20737472696e6700000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000016\
776861742061626f757420616e6f74686572206f6e6500000000000000000000\
").unwrap();
        assert_eq!((&*bytes).get_param::<String>(0)?, "random string");
        assert_eq!((&*bytes).get_param::<String>(1)?, "what about another one");

        Ok(())
    }

    #[test]
    #[rustfmt::skip]
    fn decode_string_array() -> anyhow::Result<()> {
        let bytes   = hex::decode("\
0000000000000000000000000000000000000000000000000000000000000020\
0000000000000000000000000000000000000000000000000000000000000002\
0000000000000000000000000000000000000000000000000000000000000040\
0000000000000000000000000000000000000000000000000000000000000080\
000000000000000000000000000000000000000000000000000000000000000d\
72616e646f6d20737472696e6700000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000016\
776861742061626f757420616e6f74686572206f6e6500000000000000000000\
").unwrap();
        assert_eq!((&*bytes).get_param::<Vec<String>>(0)?, 
            vec!["random string".to_owned(), "what about another one".to_owned()]);

        Ok(())
    }
}
